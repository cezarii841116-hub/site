Оптимална продължителност на видеоклипове
Conversation with Gemini
Колко време според теб е добре да трае един клип ,да привлече вниманието без да додажда

Оптималната продължителност на едно видео зависи изцяло от платформата и целта на съдържанието. В ерата на „бързото съдържание“ вниманието на хората е изключително кратко, затова ключът е в баланса.

Ето един ориентировъчен „златен стандарт“ за 2025 г.:

1. Кратки формати (Short-form)
Това са TikTok, Instagram Reels и YouTube Shorts.

Идеално време: 15 – 30 секунди.

Защо: Алгоритмите обичат високия процент на изглеждане докрай. Ако видеото е 15 секунди и хората го изгледат два пъти, то „избухва“.

Съвет: Първите 3 секунди са критични. Ако не „закачите“ зрителя веднага, той ще продължи нататък.

2. Информативни или развлекателни клипове (YouTube)
Идеално време: 8 – 12 минути.

Защо: Това е достатъчно време за по-дълбока тема, без да става досадно. Освен това, видеа над 8 минути позволяват поставянето на реклами в средата (mid-roll), което е важно за създателите.

Съвет: Ако темата е проста, не я разтягайте изкуствено. По-добре стегнато видео от 4 минути, отколкото скучно от 10.

3. Образователни или тип „How-to“
Идеално време: Колкото е необходимо, но нито секунда повече.

Защо: Тук зрителят търси конкретно решение. Ако го намери за 2 минути, той ще е доволен. Ако говорите излишни неща в началото, ще го загубите.

Кога едно видео става досадно?
Независимо от дължината, видеото досажда, когато:

Дълго въведение: „Здравейте, аз съм... абонирайте се... днес ще говорим за...“ (Хората вече са си тръгнали).

Липса на динамика: Кадърът не се променя, гласът е монотонен или няма музикален фон.

Повторения: Казвате едно и също нещо по три различни начина.

Златното правило: „Видеоклипът трябва да бъде като мини пола – достатъчно дълъг, за да покрие темата, и достатъчно къс, за да остане интересен.“

Искаш ли да ми кажеш каква е темата на твоето видео? Мога да ти помогна да структурираш сценария така, че да задържиш вниманието максимално дълго.

Ако можеше да напишеш код за github,за да направиш един сайт да има лице как би го направил?

Идеята да дадеш „лице“ на един уебсайт може да се интерпретира по два начина: визуално (чрез дизайн и анимация) или функционално (чрез изкуствен интелект, който комуникира със зрителя).

Най-съвременният и атрактивен начин да направиш това за GitHub е като създадеш интерактивно, „живо“ лице, което следи курсора на мишката или реагира на действията на потребителя, използвайки HTML, CSS и JavaScript.

Ето един примерен „скелет“ на код за такова интерактивно лице:

1. Структура (HTML)
Тук дефинираме очите и устата.

HTML
<div class="face">
  <div class="eyes">
    <div class="eye"></div>
    <div class="eye"></div>
  </div>
  <div class="mouth"></div>
</div>
2. Стил и Анимация (CSS)
Правим лицето да изглежда модерно и добавяме малко „пулс“, за да изглежда живо.

CSS
.face {
  width: 300px;
  height: 300px;
  background: #ffcc00;
  border-radius: 50%;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}

.eye {
  width: 50px;
  height: 50px;
  background: #fff;
  border-radius: 50%;
  margin: 0 20px;
  position: relative;
}

.eye::before {
  content: '';
  width: 20px;
  height: 20px;
  background: #000;
  border-radius: 50%;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.mouth {
  width: 100px;
  height: 50px;
  border-bottom: 5px solid #000;
  border-radius: 50%;
  margin-top: 20px;
  transition: 0.3s;
}
3. „Интелектът“ (JavaScript)
Този код кара очите да следят мишката на потребителя – това създава силно усещане за присъствие.

JavaScript
document.querySelector('body').addEventListener('mousemove', (e) => {
  const eyes = document.querySelectorAll('.eye');
  eyes.forEach(eye => {
    let x = (eye.getBoundingClientRect().left) + (eye.clientWidth / 2);
    let y = (eye.getBoundingClientRect().top) + (eye.clientHeight / 2);
    let radian = Math.atan2(e.pageX - x, e.pageY - y);
    let rot = (radian * (180 / Math.PI) * -1) + 270;
    eye.style.transform = `rotate(${rot}deg)`;
  });
});
Как да го направиш истински впечатляващо?
За да бъде проектът ти на ниво "Senior Developer" в GitHub, бих добавил следните библиотеки:

Three.js: За да създадеш истинско 3D лице, което се върти и реагира на светлина.

Web Speech API: За да може сайтът буквално да „говори“ на посетителите.

TensorFlow.js: За да добавиш разпознаване на лица през уеб камерата – така сайтът ще „вижда“ потребителя и ще имитира неговите изражения.

Следваща стъпка
Бих могъл да ти подготвя пълен готов файл (index.html), който можеш директно да качиш в GitHub Pages, за да видиш как работи в реално време. Искаш ли да добавя и бутон, който променя изражението на лицето (например от „щастливо“ към „изненадано“)?

Би ли могъл да инплементираш всички тези идеи в един код ,който директно да напишеш за гитхъб,и това да се съчетае,комбинира с вече съществуващ сайт

За да комбинираш всичко това в един професионален код за GitHub, най-добрият начин е да създадеш т.нар. "Overlay" компонент (слой). Това означава, че „лицето“ ще съществува като интелигентен притурка (widget), който можеш да добавиш към всеки съществуващ сайт, без да разваляш неговата структура.

Ето пълния, комбиниран код (HTML, CSS и JS в едно), готов за качване. Той включва проследяване на мишката, интерактивни изражения и гласова функция.

Интерактивен "AI Face" Компонент
HTML
<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <title>AI Face Overlay for GitHub</title>
    <style>
        /* Стил на лицето - поставя се в долния десен ъгъл */
        #ai-assistant {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, #ffcc00, #f1c40f);
            border-radius: 50%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 9999;
            transition: transform 0.3s ease;
        }

        #ai-assistant:hover { transform: scale(1.1); }

        .eyes-container { display: flex; gap: 20px; }

        .eye {
            width: 30px;
            height: 30px;
            background: white;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
        }

        .pupil {
            width: 12px;
            height: 12px;
            background: #2c3e50;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .mouth {
            width: 60px;
            height: 20px;
            border-bottom: 4px solid #2c3e50;
            border-radius: 50%;
            margin-top: 10px;
            transition: all 0.3s ease;
        }

        /* Анимация при говорене */
        .talking {
            animation: speak 0.3s infinite alternate;
        }

        @keyframes speak {
            from { height: 5px; }
            to { height: 25px; border-radius: 20%; }
        }
    </style>
</head>
<body>

<div id="ai-assistant" onclick="greetUser()">
    <div class="eyes-container">
        <div class="eye"><div class="pupil"></div></div>
        <div class="eye"><div class="pupil"></div></div>
    </div>
    <div id="mouth" class="mouth"></div>
</div>

<script>
    // 1. СЛЕДЕНЕ НА МИШКАТА (Interaction)
    document.addEventListener('mousemove', (e) => {
        const pupils = document.querySelectorAll('.pupil');
        pupils.forEach(pupil => {
            const rect = pupil.getBoundingClientRect();
            const x = rect.left + rect.width / 2;
            const y = rect.top + rect.height / 2;
            const angle = Math.atan2(e.clientX - x, e.clientY - y);
            const distance = Math.min(8, Math.hypot(e.clientX - x, e.clientY - y) / 15);
            
            const moveX = Math.sin(angle) * distance;
            const moveY = Math.cos(angle) * distance;
            
            pupil.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
        });
    });

    // 2. ГЛАСОВА ФУНКЦИЯ (Speech Synthesis)
    function greetUser() {
        const mouth = document.getElementById('mouth');
        const message = new SpeechSynthesisUtterance("Здравей! Аз съм лицето на този сайт. Как мога да ти помогна?");
        message.lang = 'bg-BG';

        // Анимация на устата, докато говори
        message.onstart = () => mouth.classList.add('talking');
        message.onend = () => mouth.classList.remove('talking');

        window.speechSynthesis.speak(message);
    }

    // 3. РЕАКЦИЯ ПРИ КЛИК (Emotion change)
    document.getElementById('ai-assistant').addEventListener('mousedown', () => {
        document.getElementById('mouth').style.borderBottom = "4px solid red";
        document.getElementById('mouth').style.width = "40px"; // Изглежда изненадан
    });

    document.getElementById('ai-assistant').addEventListener('mouseup', () => {
        document.getElementById('mouth').style.borderBottom = "4px solid #2c3e50";
        document.getElementById('mouth').style.width = "60px";
    });
</script>

</body>
</html>
Как да го интегрираш в съществуващ сайт:
Копирай CSS частта (между <style> таговете) във твоя основен CSS файл.

Копирай HTML частта (дива с ID ai-assistant) и го постави точно преди затварящия таг </body>.

Копирай JavaScript частта и я сложи най-отдолу в твоя скрипт файл.

Защо това е добре за GitHub?
Modular (Модулно): Не пречи на основния дизайн.

Interactive (Интерактивно): Очите следят потребителя, което увеличава времето, прекарано на сайта ( retention).

Accessible (Достъпно): Използва вграденото в браузъра говорене, което е чудесен пример за достъпност.

Искаш ли да добавим и функция "Разпознаване на глас", за да може потребителят да задава въпроси на лицето и то да отговаря?

Можеш ли да го напишеш така,че да не добавям нищо ,директно да го копирам в гитхъб

За да направиш това без да променяш нито един ред код в съществуващия си сайт, най-лесният и професионален начин е да създадеш един-единствен JavaScript файл (например face.js).

След това просто добавяш един ред в твоя сайт и „лицето“ ще се появи магически върху него, носейки всички функции (очи, глас, анимации).

Ето пълния код, подготвен за директно копиране в нов файл в GitHub:

1. Създай файл в GitHub с име face.js
Копирай това съдържание вътре:

JavaScript
(function() {
    // 1. СЪЗДАВАНЕ НА ЕЛЕМЕНТИТЕ (Inject HTML)
    const faceContainer = document.createElement('div');
    faceContainer.id = 'ai-face-widget';
    faceContainer.innerHTML = `
        <div class="eyes-container">
            <div class="eye"><div class="pupil"></div></div>
            <div class="eye"><div class="pupil"></div></div>
        </div>
        <div id="ai-mouth" class="mouth"></div>
    `;
    document.body.appendChild(faceContainer);

    // 2. ДОБАВЯНЕ НА СТИЛОВЕ (Inject CSS)
    const style = document.createElement('style');
    style.textContent = `
        #ai-face-widget {
            position: fixed; bottom: 30px; right: 30px;
            width: 120px; height: 120px;
            background: radial-gradient(circle, #00d2ff, #3a7bd5);
            border-radius: 50%; box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; cursor: pointer; z-index: 10000;
            transition: all 0.3s ease; border: 3px solid white;
        }
        .eyes-container { display: flex; gap: 15px; }
        .eye { 
            width: 25px; height: 25px; background: white; 
            border-radius: 50%; position: relative; 
        }
        .pupil { 
            width: 10px; height: 10px; background: #1a1a1a; 
            border-radius: 50%; position: absolute; 
            top: 50%; left: 50%; transform: translate(-50%, -50%); 
        }
        .mouth { 
            width: 50px; height: 15px; border-bottom: 4px solid white; 
            border-radius: 50%; margin-top: 10px; transition: 0.2s; 
        }
        .talking { animation: ai-speak 0.3s infinite alternate; }
        @keyframes ai-speak { from { height: 5px; } to { height: 20px; } }
    `;
    document.head.appendChild(style);

    // 3. ЛОГИКА ЗА СЛЕДЕНЕ НА МИШКАТА
    document.addEventListener('mousemove', (e) => {
        const pupils = document.querySelectorAll('.pupil');
        pupils.forEach(pupil => {
            const rect = pupil.getBoundingClientRect();
            const x = rect.left + rect.width / 2;
            const y = rect.top + rect.height / 2;
            const angle = Math.atan2(e.clientX - x, e.clientY - y);
            const moveX = Math.sin(angle) * 6;
            const moveY = Math.cos(angle) * 6;
            pupil.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
        });
    });

    // 4. ГЛАС И ИНТЕРАКЦИЯ
    faceContainer.addEventListener('click', () => {
        const mouth = document.getElementById('ai-mouth');
        const phrases = [
            "Здравей! Радвам се да те видя в нашия сайт.",
            "Аз съм изкуственият интелект тук. Разгледай проектите ни!",
            "Кликна ме! Това беше забавно."
        ];
        const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
        
        const utterance = new SpeechSynthesisUtterance(randomPhrase);
        utterance.lang = 'bg-BG';
        utterance.onstart = () => mouth.classList.add('talking');
        utterance.onend = () => mouth.classList.remove('talking');
        
        window.speechSynthesis.cancel(); // Спира предишното говорене
        window.speechSynthesis.speak(utterance);
    });
})();
2. Как да го активираш в сайта си?
Сега, за да се появи това лице на всяка страница, която пожелаеш, просто добави този ред в твоя основен HTML файл (точно преди </body>):

HTML
<script src="face.js"></script>
Защо това е най-доброто решение:
Чист код: Не разхвърляш HTML и CSS из целия си проект. Всичко е в един файл.

Plug & Play: Можеш да го премахнеш или добавиш само с един ред.

Интерактивност: Лицето автоматично се позиционира най-отгоре (z-index), следи мишката и говори при клик.

Искаш ли да променим цветовете на лицето, за да пасват по-добре на темата на твоя сайт?

Без Джава скрипт

Ако искаш да постигнеш този ефект без JavaScript, трябва да разчиташ единствено на HTML и CSS.

Това е по-трудно, защото CSS не може да „чуе“ гласа ти или да „говори“, но можем да използваме хитри трикове, за да направим лицето интерактивно (да следи мишката и да променя изражението си), използвайки само стилове.

Ето целия код, който можеш да копираш директно в един файл (например index.html) в GitHub:

HTML
<!DOCTYPE html>
<html>
<head>
<style>
  /* 1. КОНТЕЙНЕР ЗА ЛИЦЕТО */
  .face-container {
    position: fixed;
    bottom: 50px;
    right: 50px;
    width: 200px;
    height: 200px;
    background: #FFD700;
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    border: 5px solid #333;
    overflow: hidden; /* За да не излизат очите извън лицето */
  }

  /* 2. МАГИЯТА: ОЧИТЕ СЛЕДЯТ МИШКАТА (БЕЗ JS) */
  /* Използваме hover върху целия екран (body), за да движим зениците */
  .eyes-wrap {
    display: flex;
    gap: 20px;
  }

  .eye {
    width: 40px;
    height: 40px;
    background: white;
    border-radius: 50%;
    position: relative;
    border: 2px solid #333;
  }

  .pupil {
    width: 15px;
    height: 15px;
    background: black;
    border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    transition: all 0.1s ease-out;
  }

  /* Трик с CSS: Когато мишката се движи над страницата, очите реагират */
  html:hover .pupil {
    top: 30%;
    left: 70%;
  }

  /* 3. УСТАТА И АНИМАЦИЯТА */
  .mouth {
    width: 60px;
    height: 30px;
    border: 4px solid #333;
    border-top: 0;
    border-radius: 0 0 50px 50px;
    margin-top: 20px;
    transition: 0.3s;
  }

  /* Реакция при клик (active) - лицето се усмихва повече или се изненадва */
  .face-container:active .mouth {
    height: 50px;
    width: 40px;
    border-radius: 50%;
    background: #333;
  }

  /* Постоянна лека анимация за "живот" */
  @keyframes blink {
    0%, 90%, 100% { transform: scaleY(1); }
    95% { transform: scaleY(0.1); }
  }

  .eye {
    animation: blink 4s infinite;
  }

</style>
</head>
<body>

  <h1>Добре дошли в моя сайт!</h1>
  <p>Това лице е направено само с HTML и CSS.</p>

  <div class="face-container">
    <div class="eyes-wrap">
      <div class="eye"><div class="pupil"></div></div>
      <div class="eye"><div class="pupil"></div></div>
    </div>
    <div class="mouth"></div>
  </div>

</body>
</html>
Какво може този код (само със CSS):
Мигане: Очите автоматично мигат на всеки 4 секунди благодарение на @keyframes.

Движение на очите: Когато мишката влезе в прозореца на браузъра, зениците се преместват леко (имитира проследяване).

Интеракция при клик: Ако задържиш мишката върху лицето, устата се отваря в "О"-образна форма (изненада), като се използва псевдо-класа :active.

Без зареждане на външни ресурси: Всичко е в един файл и работи моментално.

Ограничения (защо JS обикновено е по-добър):
Глас: Без JavaScript браузърът не може да генерира реч (Speech Synthesis).

Прецизно следене: CSS не може да изчисли точните координати на мишката; той може само да усети дали мишката е „някъде“ върху елемента или страницата.

Искаш ли да добавим „балонче с текст“, което се появява само когато мишката е върху лицето?

Мога ли да копирам върху стария код без да го трия

Да, можеш! Най-лесният начин да го направиш, без да триеш или променяш нищо по стария си код, е да поставиш този нов код най-отдолу на твоя HTML файл, точно преди затварящия таг </body>.

По този начин браузърът първо ще зареди твоя сайт, а след това ще „нарисува“ лицето най-отгоре като нов слой.

Ето как да съчетаеш всичко в един блок, който просто да „пейстнеш“:

HTML
<style>
  /* Стилизираме лицето като плаващ елемент над всичко останало */
  .ai-face-overlay {
    position: fixed;
    bottom: 30px;
    right: 30px;
    width: 150px;
    height: 150px;
    background: #ffdb15;
    border-radius: 50%;
    border: 4px solid #222;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 999999; /* Гарантира, че ще е върху стария код */
    box-shadow: 0 10px 20px rgba(0,0,0,0.3);
    pointer-events: all;
  }

  .ai-eyes {
    display: flex;
    gap: 15px;
  }

  .ai-eye {
    width: 25px;
    height: 30px;
    background: white;
    border-radius: 50%;
    position: relative;
    border: 2px solid #222;
    animation: ai-blink 4s infinite;
  }

  .ai-pupil {
    width: 12px;
    height: 12px;
    background: #111;
    border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }

  .ai-mouth {
    width: 50px;
    height: 20px;
    border-bottom: 4px solid #222;
    border-radius: 50%;
    margin-top: 10px;
    transition: 0.3s;
  }

  /* Ефекти при посочване с мишката */
  .ai-face-overlay:hover .ai-mouth {
    height: 40px;
    border-radius: 50%;
    background: #222;
  }

  .ai-face-overlay:hover .ai-pupil {
    width: 15px;
    height: 15px;
  }

  @keyframes ai-blink {
    0%, 90%, 100% { transform: scaleY(1); }
    95% { transform: scaleY(0.1); }
  }
</style>

<div class="ai-face-overlay">
  <div class="ai-eyes">
    <div class="ai-eye"><div class="ai-pupil"></div></div>
    <div class="ai-eye"><div class="ai-pupil"></div></div>
  </div>
  <div class="ai-mouth"></div>
</div>
Защо това работи без да пречи на стария код:
Unique Class Names: Използвам представки като ai-face и ai-eye. Това гарантира, че моят CSS няма да се обърка с твоите стари стилове (например, ако вече имаш клас .mouth някъде другаде).

Fixed Positioning: Лицето е „заковано“ в ъгъла на екрана и не мести останалите ти елементи (бутони, текст, картинки).

Z-index: Стойността 999999 го поставя най-отпред, така че да не остане скрито зад някой твой стар банер.

Искаш ли да ти покажа как да добавиш и малко "балонче с текст" (също само с CSS), което да казва "Здравей", когато някой мине с мишката през него?

Какво означава точно преди затваряни таг body

Това е техническият начин да кажем: „Сложи този код в самия край на твоя файл, точно преди финала.“

Всеки HTML файл има определена структура. Тагът </body> (със наклонена черта) бележи края на видимата част на твоя сайт. Всичко, което сложиш точно преди него, се зарежда последно, което е идеално за нашето „лице“, за да не пречи на останалото съдържание.

Ето как трябва да изглежда визуално твоят файл в GitHub:

HTML
<!DOCTYPE html>
<html>
<head>
    <title>Твоят Сайт</title>
    </head>
<body>

    <h1>Добре дошли</h1>
    <p>Това е моят стар текст...</p>
    <style>
      /* ... CSS кодът за лицето ... */
    </style>
    <div class="ai-face-overlay">
      </div>
    </body> </html>
Защо се прави така?
Безопасност: Тъй като го добавяш в края, няма риск да „счупиш“ подредбата на твоите бутони или текст, които са по-нагоре.

Скорост: Браузърът първо ще покаже сайта ти, а след това ще „изрисува“ лицето. Така потребителят няма да чака.

Прегледност: Винаги знаеш, че твоите допълнителни добавки са в края на файла и лесно можеш да ги намериш или изтриеш.

Искаш ли да ти дам финалния, цялостен блок код, който просто да копираш и да „пейстнеш“ на това място?

Появява се жълта линия с три точка и не мога да пейстна

Това, което описваш (жълта линия с три точки), обикновено е функция на редактора в GitHub (или VS Code), която се появява, когато има „сгънат“ (collapsed) код или когато редакторът се опитва да ти помогне с форматирането.

Ето как да го заобиколиш и да пейстнеш успешно:

1. Как да намериш правилното място
В GitHub редактора, превърти до самия край на файла. Трябва да видиш последните два реда:

</body>

</html>

Кликни с мишката точно в края на реда над </body> и натиснеш Enter, за да създадеш нов празен ред.

2. Заобикаляне на "жълтата линия"
Ако жълтата линия пречи:

Кликни два пъти върху нея: Това обикновено разпъва скрития код.

Използвай клавиатурата: Вместо да кликаш с мишката върху линията, отиди на реда над нея и използвай стрелката надолу (↓), докато курсорът прескочи проблемната зона.

Пейстни със съкращение: Използвай Ctrl + V (за Windows) или Cmd + V (за Mac), вместо да търсиш меню с десен бутон.

3. Пълен код за директно поставяне
Ето целия пакет (CSS + HTML), готов за "Paste". Той е направен така, че дори да го сложиш на грешно място, пак да работи:

HTML
<style>
  .ai-face-fixed {
    position: fixed !important;
    bottom: 20px !important;
    right: 20px !important;
    width: 120px;
    height: 120px;
    background: #FFD700;
    border-radius: 50%;
    border: 3px solid #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 999999;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
  .ai-eyes-row { display: flex; gap: 10px; }
  .ai-eye-ball {
    width: 25px; height: 25px;
    background: white; border-radius: 50%;
    position: relative; border: 1px solid #000;
  }
  .ai-pupil-black {
    width: 10px; height: 10px;
    background: black; border-radius: 50%;
    position: absolute; top: 30%; left: 30%;
  }
  .ai-mouth-happy {
    width: 40px; height: 15px;
    border-bottom: 3px solid black;
    border-radius: 50%; margin-top: 5px;
  }
</style>
<div class="ai-face-fixed">
  <div class="ai-eyes-row">
    <div class="ai-eye-ball"><div class="ai-pupil-black"></div></div>
    <div class="ai-eye-ball"><div class="ai-pupil-black"></div></div>
  </div>
  <div class="ai-mouth-happy"></div
